'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = makeMangakakalotAdapter;

var _cheerio = require('cheerio');

var _cheerio2 = _interopRequireDefault(_cheerio);

var _momentTimezone = require('moment-timezone');

var _momentTimezone2 = _interopRequireDefault(_momentTimezone);

var _errors = require('../../errors');

var _errors2 = _interopRequireDefault(_errors);

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

const DATE_FORMAT = 'YYYY-MM-DD HH:mm';
const TZ = 'Asia/Hong_Kong';

const getFirstWord = string => string.split(' ').shift();
const getNumber = string => parseInt(string, 10);

/*
 * Takes a year and a MM-DD HH:mm timestamp and returns a full unix timestamp.
 */
const getUnixFromTimestamp = (year, date) => _momentTimezone2.default.tz(`${year}-${date}`, DATE_FORMAT, TZ).unix();

/*
 * Mangakakalot shows dates in two formats: "19 hour ago" and "12-25 18:09".
 * This function normalizes them to both follow the "MM-DD HH:mm" format.
 */
const normalizeTimestampFormat = timestamp => {
  if (timestamp.endsWith('ago')) {
    const offset = getNumber(getFirstWord(timestamp));
    const now = (0, _momentTimezone2.default)();
    return now.subtract(offset, 'hours').startOf('hour').format('MM-DD HH:mm');
  }

  return timestamp;
};

/*
 * Mangakakalot shows chapter numbers in a bunch of formats, but the two most
 * common are "Vol.2 Chapter 5" and "Chapter 19". This function extracts the
 * number from all the chapter formats.
 */
const extractChapterNumber = input => {
  const matches = /chapter\s+([\d.]+)/i.exec(input);

  if (matches === null) {
    return null;
  }

  return matches.length > 1 ? matches[1] : null;
};

const parseAuthors = input => {
  const parts = input.split(':');
  const authors = parts[1].split(',');

  return authors;
};

// http://mangakakalot.com/manga/<series-id>
// http://mangakakalot.com/chapter/<series-id>/chapter_<chapter-id>

function makeMangakakalotAdapter({
  id: siteId,
  name: siteName,
  domain
}) {
  return {
    id: siteId,
    name: siteName,

    supportsUrl(url) {
      return _utils2.default.compareDomain(url, this._getHost());
    },

    supportsReading() {
      return true;
    },

    parseUrl(url) {
      const matches = _utils2.default.pathMatch(url, '/:type(manga|chapter)/:seriesSlug/:chapterSlug(chapter_[0-9.]+)?(/.+)?');

      (0, _utils.invariant)(matches, new _errors2.default.InvalidUrlError(url));
      (0, _utils.invariant)(matches.seriesSlug, new _errors2.default.InvalidUrlError(url));

      const { seriesSlug } = matches;
      const chapterSlug = matches.type === 'chapter' ? matches.chapterSlug : null;

      return { seriesSlug, chapterSlug };
    },

    constructUrl(seriesSlug, chapterSlug) {
      const isChapter = chapterSlug !== null && chapterSlug !== undefined;

      const parts = [this._getHost(), isChapter ? 'chapter' : 'manga', seriesSlug];

      if (isChapter) {
        parts.push(chapterSlug);
      }

      return _utils2.default.normalizeUrl(parts.join('/'));
    },

    _getHost() {
      return domain;
    },

    async getSeries(seriesSlug) {
      const url = this.constructUrl(seriesSlug);
      const html = await _utils2.default.getPage(url);
      const dom = _cheerio2.default.load(html);

      (0, _utils.invariant)(html.indexOf('requested cannot be found') === -1, new _errors2.default.NotFoundError(url));

      const $infoSection = dom('ul.manga-info-text');
      const $chapterRows = dom('.row', '.chapter-list');

      const title = $infoSection.find('h1').first().text().trim();
      const description = dom('#noidungm').contents().not('h2').text().trim();

      const $authorInfo = $infoSection.find('li').eq(1);
      const $statusInfo = $infoSection.find('li').eq(2);

      const authors = parseAuthors($authorInfo.text());
      // $FlowFixMe: Flow doesn't recognize that Array<string> is compatible with Array<?string>
      const author = _utils2.default.formatAuthors(authors);
      const status = _utils2.default.parseStatus($statusInfo.text());
      const coverImageUrl = dom('img', 'div.manga-info-pic').attr('src');

      const updatedAtRawText = $infoSection.find('li').eq(3).text().trim();
      const updatedAtText = updatedAtRawText.split('Last updated : ').pop();
      const updatedAtTimestamp = _momentTimezone2.default.tz(updatedAtText, 'MMM-DD-YYYY HH:mm:ss A', TZ);
      const updatedAt = updatedAtTimestamp.unix();

      const chapterRawData = $chapterRows.get().map(el => {
        const link = dom('a', el);
        const linkText = link.text().trim();

        const title = linkText.split(' : ')[1];
        const chapterNumber = extractChapterNumber(linkText);
        // NOTE: no formal concept of volumes on Mangakakalot
        const href = link.attr('href');
        const slug = href.split('/').pop();
        const url = this.constructUrl(seriesSlug, slug);

        const createdAtText = normalizeTimestampFormat(dom('span', el).eq(2).text().trim());

        return {
          slug,
          title,
          url,
          chapterNumber,
          createdAtText
        };
      });

      // NOTE: since Mangakakalot doesn't give the year with a chapter timestamp,
      // we assume the most recent chapter matches the updatedAt timestamp for the
      // series. Then, we work backwards, assuming each chapter was released
      // before later ones.

      let lastUpdatedYear = updatedAtTimestamp.year();

      const chapters = chapterRawData.map((chapterData, i, arr) => {
        const prev = arr[i - 1];
        const { createdAtText } = chapterData,
              rest = _objectWithoutProperties(chapterData, ['createdAtText']);

        let createdAt = getUnixFromTimestamp(lastUpdatedYear, createdAtText);

        if (prev) {
          const prevCreatedAt = getUnixFromTimestamp(lastUpdatedYear, prev.createdAtText);

          if (prevCreatedAt < createdAt) {
            lastUpdatedYear -= 1;
            createdAt = _momentTimezone2.default.unix(createdAt).year(lastUpdatedYear).unix();
          }
        }

        return Object.assign({}, rest, { createdAt });
      });

      return {
        slug: seriesSlug,
        title,
        description,
        author,
        status,
        coverImageUrl,
        url,
        chapters,
        updatedAt
      };
    },

    async getChapter(seriesSlug, chapterSlug) {
      const url = this.constructUrl(seriesSlug, chapterSlug);
      const html = await _utils2.default.getPage(url);
      const dom = _cheerio2.default.load(html);

      const pages = dom('img', '#vungdoc').get().map(el => {
        const pageUrl = dom(el).attr('src');
        const id = pageUrl.split('/').pop().split('_').shift();

        return { id, url: pageUrl };
      });

      return { slug: chapterSlug, url, pages };
    }
  };
}
module.exports = exports['default'];