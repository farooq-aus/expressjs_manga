'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cheerio = require('cheerio');

var _cheerio2 = _interopRequireDefault(_cheerio);

var _momentTimezone = require('moment-timezone');

var _momentTimezone2 = _interopRequireDefault(_momentTimezone);

var _pThrottle = require('p-throttle');

var _pThrottle2 = _interopRequireDefault(_pThrottle);

var _errors = require('../errors');

var _errors2 = _interopRequireDefault(_errors);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const throttledGetPage = (0, _pThrottle2.default)(_utils2.default.getPage, 1, 600);

function parsePublicationStatus(input) {
  const status = input.toLowerCase();

  if (status === 'ongoing') {
    return 'ONGOING';
  } else if (status === 'completed') {
    return 'COMPLETED';
  }

  return 'UNKNOWN';
}

function parseChapterDate(input) {
  return _momentTimezone2.default.tz(input, 'ddd, DD MMM YYYY HH:mm:ss Z', 'GMT').unix();
}

function extractArgs(str) {
  // NOTE: This is a brittle approach, relying on the fact this variable is
  // named 'p'. That said, it's surprisingly easy and works.
  const startArgs = `return p;}('`;
  const argsStartIndex = str.indexOf(startArgs) + startArgs.length - 1;
  const argsEndIndex = str.indexOf('))', argsStartIndex);

  return str.substring(argsStartIndex, argsEndIndex).split(',');
}

function extractKeyFromCode(str) {
  // Removes the non-<key> part of the string: '<key>'.split('|')
  return str.replace(/\.split\('\|'\)$/, '').replace(/^'|'$/g, '');
}

function extractChapterKey(html) {
  const args = extractArgs(html);

  const dm5String = args[0];
  const rawKeyString = extractKeyFromCode(args[3]);
  const decodedChapterKey = _utils2.default.decodeDM5String(dm5String, rawKeyString);

  const firstEqualsIndex = decodedChapterKey.indexOf('=');
  const firstSemicolonIndex = decodedChapterKey.indexOf(';');
  const assignment = decodedChapterKey.substring(firstEqualsIndex + 1, firstSemicolonIndex);
  const cleanedChapterKey = assignment.replace(/[^0-9a-fA-F]/g, '');

  return cleanedChapterKey;
}

function extractPageIndex(code) {
  const args = extractArgs(code);
  const dm5String = args.length > 6 ? args[0] + ',' + args[1] : args[0];
  const key = extractKeyFromCode(args.length > 6 ? args[4] : args[3]);

  const decoded = _utils2.default.decodeDM5String(dm5String, key);

  const betweenQuotes = /"([^"]+)"/g;
  const matches = decoded.match(betweenQuotes);

  if (!Array.isArray(matches)) {
    throw new Error('Could not find image URLs');
  }

  const normalizedMatches = matches.map(str => str.replace(/"/g, ''));

  const host = normalizedMatches[0].replace('http:', 'https:');
  const imagePaths = normalizedMatches.slice(1, -1);

  const imageUrls = imagePaths.map(path => host + path);

  return imageUrls;
}

const MangaFoxAdapter = {
  id: 'manga-fox',
  name: 'MangaFox',

  supportsUrl(url) {
    return (/^https?:\/\/(www\.)?fanfox.net/.test(url)
    );
  },

  supportsReading() {
    return true;
  },

  parseUrl(url) {
    // https://fanfox.net/manga/shokugeki_no_soma/
    // https://fanfox.net/manga/tomo_chan_wa_onnanoko/
    // https://fanfox.net/manga/tomo_chan_wa_onnanoko/c176.1/1.html
    // https://fanfox.net/manga/tomo_chan_wa_onnanoko/c870/1.html
    // https://fanfox.net/manga/horimiya/v12/c088/1.html

    const u = _utils2.default.parseUrl(url);
    const parts = u.pathname.split('/').filter(Boolean);

    const isValidUrl = parts.length > 1 && parts[0] === 'manga';

    (0, _utils.invariant)(isValidUrl, new _errors2.default.InvalidUrlError(url));

    const seriesSlug = parts[1];
    const chapterSlug = parts.find(p => /c[0-9.]+/.test(p)) || null;

    (0, _utils.invariant)(seriesSlug, new _errors2.default.InvalidUrlError(url));

    return { seriesSlug, chapterSlug };
  },

  constructUrl(seriesSlug, chapterSlug) {
    (0, _utils.invariant)(typeof seriesSlug === 'string', new TypeError(`'seriesSlug' must be a string, not ${typeof seriesSlug}`));

    const parts = [this._getHost(), 'manga', seriesSlug, chapterSlug ? chapterSlug : null].filter(Boolean);

    return parts.join('/') + '/';
  },

  _getHost() {
    return `https://fanfox.net`;
  },

  async getSeries(seriesSlug) {
    const url = this.constructUrl(seriesSlug);

    const html = await _utils2.default.getPage(url);
    const dom = _cheerio2.default.load(html);

    const $intro = dom('p.detail-info-right-title').first();
    const $status = $intro.find('.detail-info-right-title-tip');
    const $author = dom('.detail-info-right-say > a');
    const $description = dom('.fullcontent').first();
    const $coverImage = dom('.detail-info-cover-img').first();

    const title = $coverImage.attr('alt');
    const description = $description.text().trim();
    const author = $author.attr('title').trim();
    const status = parsePublicationStatus($status.text().trim());
    const coverImageUrl = $coverImage.attr('src');

    const chapterListingUrl = `${this._getHost()}/rss/${seriesSlug}.xml`;
    const xml = await _utils2.default.getPage(chapterListingUrl);
    const rss = _cheerio2.default.load(xml, { xmlMode: true });

    const $chapterList = rss('item').get();

    const chapters = $chapterList.map(el => {
      const $item = rss(el);
      const $description = $item.find('description');
      const $link = $item.find('link');
      const $date = $item.find('pubDate');

      const url = $link.text();
      const { chapterSlug: slug } = this.parseUrl(url);

      const chapterNumber = slug.replace(/^c/, '').replace(/^0+/, '');
      const title = $description.text().trim() || undefined;
      const createdAt = parseChapterDate($date.text().trim());

      return {
        slug,
        url,
        title,
        chapterNumber,
        createdAt
      };
    });

    return {
      slug: seriesSlug,
      title,
      description,
      author,
      status,
      coverImageUrl,
      url,
      chapters
    };
  },

  async getChapter(seriesSlug, chapterSlug) {
    const url = this.constructUrl(seriesSlug, chapterSlug);
    const html = await _utils2.default.getPage(url, {
      headers: {
        // Prevents a prompt which blocks common series like Shingeki no Kyojin
        // and Re: Monster.
        cookie: 'isAdult=1'
      }
    });

    const chapterId = _utils2.default.extractText(/var\s*chapterid\s*=\s*(\d+);/i, html);
    const chapterKey = extractChapterKey(html);

    const pageLinks = html.match(/data-page="(\d+)"/g) || [];

    const pageCount = pageLinks.map(match => match.replace(/\D+/g, '')).map(number => parseInt(number, 10)).reduce((a, b) => Math.max(a, b), 1);

    let imageSet = new Set();
    let count = 1;

    while (imageSet.size < pageCount) {
      const pageIndexUrl = url + 'chapterfun.ashx' + `?cid=${chapterId}&page=${count}&key=${chapterKey}`;

      const pageIndex = await _utils2.default.getPage(pageIndexUrl, {
        headers: { Referer: url }
      });

      const newUrls = extractPageIndex(pageIndex);
      count = Math.min(count + newUrls.length, pageCount);

      newUrls.forEach(url => {
        imageSet.add(url);
      });
    }

    const imageUrls = [...imageSet];

    const pages = imageUrls.map((url, i) => {
      const id = `${chapterId}:${i}`;
      return { id, url };
    });

    return { slug: chapterSlug, url, pages };
  }
};

exports.default = MangaFoxAdapter;
module.exports = exports['default'];