'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cheerio = require('cheerio');

var _cheerio2 = _interopRequireDefault(_cheerio);

var _momentTimezone = require('moment-timezone');

var _momentTimezone2 = _interopRequireDefault(_momentTimezone);

var _pThrottle = require('p-throttle');

var _pThrottle2 = _interopRequireDefault(_pThrottle);

var _errors = require('../errors');

var _errors2 = _interopRequireDefault(_errors);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TZ = 'America/Los_Angeles';

const t = $el => $el.text().trim();
const throttledGetPage = (0, _pThrottle2.default)(_utils2.default.getPage, 1, 600);
const trimLeadingZeroes = str => str.replace(/^0+(\d)/g, '$1');

function extractArgs(str) {
  // NOTE: This is a brittle approach, relying on the fact this variable is
  // named 'p'. That said, it's surprisingly easy and works.
  const startArgs = `return p;}('`;
  const argsStartIndex = str.indexOf(startArgs) + startArgs.length - 1;
  const argsEndIndex = str.indexOf('))', argsStartIndex);

  return str.substring(argsStartIndex, argsEndIndex).split(',');
}

function extractKeyFromCode(str) {
  // Removes the non-<key> part of the string: '<key>'.split('|')
  return str.replace(/\.split\('\|'\)$/, '').replace(/^'|'$/g, '');
}

function extractChapterKey(html) {
  const args = extractArgs(html);

  const dm5String = args[0];
  const rawKeyString = extractKeyFromCode(args[3]);
  const decodedChapterKey = _utils2.default.decodeDM5String(dm5String, rawKeyString);

  const firstEqualsIndex = decodedChapterKey.indexOf('=');
  const firstSemicolonIndex = decodedChapterKey.indexOf(';');
  const assignment = decodedChapterKey.substring(firstEqualsIndex + 1, firstSemicolonIndex);
  const cleanedChapterKey = assignment.replace(/[^0-9a-fA-F]/g, '');

  return cleanedChapterKey;
}

function extractPageIndex(code) {
  const args = extractArgs(code);
  const dm5String = args.length > 6 ? args[0] + ',' + args[1] : args[0];
  const key = extractKeyFromCode(args.length > 6 ? args[4] : args[3]);

  const decoded = _utils2.default.decodeDM5String(dm5String, key);

  const betweenQuotes = /"([^"]+)"/g;
  const matches = decoded.match(betweenQuotes);

  if (!Array.isArray(matches)) {
    throw new Error('Could not find image URLs');
  }

  const normalizedMatches = matches.map(str => str.replace(/"/g, ''));

  const host = normalizedMatches[0].replace('http:', 'https:');
  const imagePaths = normalizedMatches.slice(1, -1);

  const imageUrls = imagePaths.map(path => host + path);

  return imageUrls;
}

function extractChapterMetadata(html, getChapterUrl) {
  const dom = _cheerio2.default.load(html);
  const chapterDom = dom('.detail-main-list');
  const chapterListElements = chapterDom.find('li');

  const chapterMetadata = chapterListElements.get().map(el => {
    const $row = dom(el);
    const $link = $row.find('a');
    const $title = $row.find('.title3');
    const $date = $row.find('.title2');

    const href = $link.attr('href');
    const slug = _utils2.default.extractText(/\/(c[\d.]+)\/?/, href);
    const url = getChapterUrl(slug);

    const [rawChapterString, title] = t($title).split(' - ');
    const chapterNumber = trimLeadingZeroes(_utils2.default.extractText(/Ch.([\d.]+)$/i, rawChapterString));
    // NOTE: MangaHere has no notion of volumes

    const createdAt = getTimestamp(t($date));

    return { slug, title, url, chapterNumber, createdAt };
  });

  return chapterMetadata;
}

function getTimestamp(rawText) {
  const text = rawText.toLowerCase();

  if (text.includes('hours ago')) {
    const rawCount = _utils2.default.extractText(/(\d+) hours ago/, text);
    const count = parseInt(rawCount, 10);

    return _momentTimezone2.default.tz(TZ).subtract(count, 'hours').unix();
  }

  if (text === 'today') {
    return _momentTimezone2.default.tz(TZ).endOf('day').unix();
  }

  if (text === 'yesterday') {
    return _momentTimezone2.default.tz(TZ).subtract(1, 'day').endOf('day').unix();
  }

  return _momentTimezone2.default.tz(text, 'MMM D,YYYY', 'America/Los_Angeles').unix();
}

const MangaHereAdapter = {
  id: 'manga-here',
  name: 'Manga Here',

  supportsUrl(url) {
    return (/^https?:\/\/(www\.)?mangahere.(co|cc)/.test(url)
    );
  },

  supportsReading() {
    return true;
  },

  parseUrl(url) {
    const matches = _utils2.default.pathMatch(url, '/manga/:seriesSlug/:chapterSlug(c[0-9.]+)?(/.+)?');

    (0, _utils.invariant)(matches, new _errors2.default.InvalidUrlError(url));
    (0, _utils.invariant)(matches.seriesSlug, new _errors2.default.InvalidUrlError(url));

    const { seriesSlug, chapterSlug = null } = matches;

    return { seriesSlug, chapterSlug };
  },

  constructUrl(seriesSlug, chapterSlug) {
    (0, _utils.invariant)(typeof seriesSlug === 'string', new TypeError(`'seriesSlug' must be a string, not ${typeof seriesSlug}`));

    return _utils2.default.normalizeUrl(`${this._getHost()}/manga/${seriesSlug}/${chapterSlug || ''}`);
  },

  _getHost() {
    return `https://www.mangahere.cc`;
  },

  async getSeries(seriesSlug) {
    const url = this.constructUrl(seriesSlug);
    const html = await throttledGetPage(url);

    (0, _utils.invariant)(html.indexOf('page you have requested canâ€™t be found') === -1, new _errors2.default.NotFoundError(url));

    const dom = _cheerio2.default.load(html);

    const title = t(dom('.detail-info-right-title-font'));
    const description = t(dom('.fullcontent'));

    const author = _utils2.default.formatAuthors([t(dom('.detail-info-right-say > a'))]);
    const status = _utils2.default.parseStatus(t(dom('.detail-info-right-title-tip')));
    const coverImageUrl = dom('img.detail-info-cover-img').attr('src');

    const getChapterUrl = slug => this.constructUrl(seriesSlug, slug);
    const chapters = extractChapterMetadata(html, getChapterUrl);

    return {
      slug: seriesSlug,
      title,
      description,
      author,
      status,
      coverImageUrl,
      url,
      chapters
    };
  },

  async getChapter(seriesSlug, chapterSlug) {
    const url = this.constructUrl(seriesSlug, chapterSlug);
    const html = await _utils2.default.getPage(url, {
      headers: {
        // Prevents a prompt which blocks common series like Shingeki no Kyojin
        // and Re: Monster.
        cookie: 'isAdult=1'
      }
    });

    if (html.includes('According to the requirement of the Copyright Party')) {
      throw new _errors2.default.LicenseError();
    }

    const chapterId = _utils2.default.extractText(/var\s*chapterid\s*=\s*(\d+);/i, html);
    const chapterKey = extractChapterKey(html);

    const pageLinks = html.match(/data-page="(\d+)"/g) || [];

    const pageCount = pageLinks.map(match => match.replace(/\D+/g, '')).map(number => parseInt(number, 10)).reduce((a, b) => Math.max(a, b), 1);

    let imageSet = new Set();
    let count = 1;

    while (imageSet.size < pageCount) {
      const pageIndexUrl = url + '/chapterfun.ashx' + `?cid=${chapterId}&page=${count}&key=${chapterKey}`;

      const pageIndex = await _utils2.default.getPage(pageIndexUrl, {
        headers: { Referer: url }
      });

      const newUrls = extractPageIndex(pageIndex);
      count = Math.min(count + newUrls.length, pageCount);

      newUrls.forEach(url => {
        imageSet.add(url);
      });
    }

    const imageUrls = [...imageSet];

    const pages = imageUrls.map((url, i) => {
      const id = `${chapterId}:${i}`;
      return { id, url };
    });

    return { slug: chapterSlug, url, pages };
  }
};

exports.default = MangaHereAdapter;
module.exports = exports['default'];