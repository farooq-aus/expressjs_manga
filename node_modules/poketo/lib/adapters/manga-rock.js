'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pThrottle = require('p-throttle');

var _pThrottle2 = _interopRequireDefault(_pThrottle);

var _errors = require('../errors');

var _errors2 = _interopRequireDefault(_errors);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const throttledGetJSON = (0, _pThrottle2.default)(_utils2.default.getJSON, 1, 600);

const getIdFromOid = oid => oid.split('-').pop();
const parseTitle = input => {
  const parts = input.split(': ');
  const title = parts[1];

  let chapterNumber;
  let volumeNumber;

  try {
    chapterNumber = _utils2.default.extractText(/chapter\s+([\d.]+)/i, parts[0]);
  } catch (err) {}

  try {
    volumeNumber = _utils2.default.extractText(/vol\.\s*([\d.]+)/i, parts[0]);
  } catch (err) {}

  if (volumeNumber === 'TBD') {
    volumeNumber = undefined;
  }

  return { title, chapterNumber, volumeNumber };
};

const parseAuthors = data => data.authors.length > 0 ? data.authors.map(author => author.name) : [null];

const validateStatusCode = (code, url) => {
  switch (code) {
    case 0:
      return;
    case 103:
    case 106:
    case 110:
      throw new _errors2.default.NotFoundError(url);
    case 104:
      throw new _errors2.default.LicenseError();
    case 109:
      throw new _errors2.default.HTTPError(400, 'Unknown query version', url);
  }
};

/*
 * MangaRock is a special snowflake; they encode their images as base64'd WebP
 * files with a few header bits taken out. I wrote a micro-service to decode
 * these files into .webp files, which can be passed directly to a browser.
 */
const getPage = async url => {
  const decodedUrl = `https://mri-image-decoder.now.sh/?url=${url}`;

  return {
    id: url.split('/').pop(),
    url: decodedUrl
  };
};

const MangaRockAdapter = {
  id: 'manga-rock',
  name: 'Manga Rock',

  supportsUrl(url) {
    return _utils2.default.compareDomain(url, 'https://mangarock.com');
  },

  supportsReading() {
    return true;
  },

  parseUrl(url) {
    const u = _utils2.default.parseUrl(url);
    const parts = u.pathname.split('/');
    const seriesMarkerIndex = parts.findIndex(p => p === 'manga');
    const chapterMarkerIndex = parts.findIndex(p => p === 'chapter');

    const seriesPart = parts[seriesMarkerIndex + 1];
    const chapterPart = parts[chapterMarkerIndex + 1];

    (0, _utils.invariant)(seriesPart, new _errors2.default.InvalidUrlError(url));

    const seriesSlug = getIdFromOid(seriesPart);
    const chapterSlug = chapterPart ? getIdFromOid(chapterPart) : null;

    return { seriesSlug, chapterSlug };
  },

  constructUrl(seriesSlug, chapterSlug) {
    (0, _utils.invariant)(typeof seriesSlug === 'string', new TypeError(`'seriesSlug' must be a string, not ${typeof seriesSlug}`));

    const parts = ['https://mangarock.com/manga', `mrs-serie-${seriesSlug}`, chapterSlug ? `chapter/mrs-chapter-${chapterSlug}` : undefined].filter(Boolean);

    return parts.join('/');
  },

  _getHost() {
    return `https://api.mangarockhd.com`;
  },

  async getSeries(seriesSlug) {
    const url = this.constructUrl(seriesSlug);
    const json = await throttledGetJSON(`${this._getHost()}/query/web401/info?oid=mrs-serie-${seriesSlug}`);

    validateStatusCode(json.code, url);

    const {
      name: title,
      description,
      completed,
      thumbnail: coverImageUrl
    } = json.data;

    const author = _utils2.default.formatAuthors(parseAuthors(json.data));
    const status = completed ? 'COMPLETED' : 'ONGOING';

    const chapters = json.data.chapters.sort((a, b) => b.order - a.order).map(chapterData => {
      const slug = getIdFromOid(chapterData.oid);
      const createdAt = chapterData.updatedAt;
      const { title, chapterNumber, volumeNumber } = parseTitle(chapterData.name);
      const url = this.constructUrl(seriesSlug, slug);

      return { slug, title, url, createdAt, chapterNumber, volumeNumber };
    });

    return {
      slug: seriesSlug,
      title,
      description,
      author,
      status,
      coverImageUrl,
      url,
      chapters
    };
  },

  async getChapter(seriesSlug, chapterSlug) {
    const url = this.constructUrl(seriesSlug, chapterSlug);
    const pagesJSON = await throttledGetJSON(`${this._getHost()}/query/web401/pages?oid=mrs-chapter-${chapterSlug}`);

    validateStatusCode(pagesJSON.code, url);

    const pages = await Promise.all(pagesJSON.data.map(url => getPage(url)));

    return { slug: chapterSlug, url, pages };
  }
};

exports.default = MangaRockAdapter;
module.exports = exports['default'];