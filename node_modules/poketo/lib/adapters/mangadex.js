'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _he = require('he');

var _he2 = _interopRequireDefault(_he);

var _momentTimezone = require('moment-timezone');

var _momentTimezone2 = _interopRequireDefault(_momentTimezone);

var _pThrottle = require('p-throttle');

var _pThrottle2 = _interopRequireDefault(_pThrottle);

var _errors = require('../errors');

var _errors2 = _interopRequireDefault(_errors);

var _get = require('../get');

var _get2 = _interopRequireDefault(_get);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

const throttledGet = (0, _pThrottle2.default)(_utils2.default.getJSON, 5, 500);

const LanguageCodes = {
  ENGLISH: 'gb',
  SPANISH: 'es',
  RUSSIAN: 'ru'
};

const StatusCodes = {
  '1': 'ONGOING',
  '2': 'COMPLETED'
};

/*
 * Since Poketo has no notion of languages or multiple versions of a chapter,
 * we'll just return the English version. Sorry, international peeps :(
 */
const filterLanguage = chapter => {
  return chapter.language === LanguageCodes.ENGLISH;
};

/*
 * Mangadex has "pre-release chapters", showing information before the actual
 * publication. If the timestamp is in the future, we ignore it.
 */
const filterPreReleases = chapter => {
  const now = (0, _momentTimezone2.default)().unix();
  return chapter.createdAt <= now;
};

/*
 * Mangadex supports multiple scanlators uploading versions of the same chapter.
 * We take the most recently uploaded version to filter out speed-scanlators.
 */
const filterDuplicates = (chapter, _, arr) => {
  const duplicateChapters = arr.filter(d => d.volumeNumber === chapter.volumeNumber && d.chapterNumber === chapter.chapterNumber && d.slug !== chapter.slug);

  if (duplicateChapters.length === 0) {
    return true;
  }

  return duplicateChapters.every(d => chapter.createdAt > d.createdAt);
};

const MangadexAdapter = {
  id: 'mangadex',
  name: 'Mangadex',

  supportsUrl(url) {
    return _utils2.default.compareDomain(url, this._getHost());
  },

  supportsReading() {
    return true;
  },

  parseUrl(url) {
    // https://mangadex.org/title/13127
    // https://mangadex.org/manga/13127/uramikoi-koi-uramikoi
    // https://mangadex.org/chapter/37149/1

    const matches = _utils2.default.pathMatch(url, '/:type(manga|title|chapter)/:first/:second?');

    (0, _utils.invariant)(matches, new _errors2.default.InvalidUrlError(url));
    (0, _utils.invariant)(matches.first, new _errors2.default.InvalidUrlError(url));

    const isChapter = matches.type === 'chapter';
    const seriesSlug = isChapter ? null : matches.first;
    const chapterSlug = isChapter ? matches.first : null;

    return { seriesSlug, chapterSlug };
  },

  constructUrl(seriesSlug, chapterSlug) {
    const type = chapterSlug ? 'chapter' : 'title';
    const slug = type === 'chapter' ? chapterSlug : seriesSlug;

    (0, _utils.invariant)(slug, new TypeError(`Either 'seriesSlug' or 'chapterSlug' must be a string, not ${typeof seriesSlug} and ${typeof chapterSlug}`));

    return _utils2.default.normalizeUrl(`${this._getHost()}/${type}/${slug}`);
  },

  _getHost() {
    return `https://mangadex.org`;
  },

  async getSeries(seriesSlug) {
    const url = this.constructUrl(seriesSlug);
    const json = await throttledGet(`${this._getHost()}/api/manga/${seriesSlug}`);

    const {
      title: rawTitle,
      description: rawDescription,
      cover_url: rawCoverImageUrl
    } = json.manga;

    const title = _he2.default.decode(rawTitle);
    const description = _utils2.default.stripBBCode(_he2.default.decode(rawDescription));
    const author = _utils2.default.formatAuthors([json.manga.author, json.manga.artist]);
    const status = StatusCodes[json.manga.status] || 'UNKNOWN';
    // We swap out the URL to get a "large" thumbnail-sized version.
    const coverImageUrl = this._getHost() + rawCoverImageUrl.replace('.jpg', '.large.jpg');

    // If the chapter object doesn't exist, the series doesn't have any chapters
    // available to read.
    const chapterIds = json.chapter ? Object.keys(json.chapter) : [];
    const chapterData = chapterIds.map(id => {
      const chapter = json.chapter[id];

      return {
        slug: id,
        title: chapter.title,
        url: this.constructUrl(seriesSlug, id),
        language: chapter.lang_code,
        chapterNumber: chapter.chapter ? chapter.chapter : undefined,
        volumeNumber: chapter.volume ? chapter.volume : undefined,
        createdAt: chapter.timestamp
      };
    });

    const chapters = chapterData.filter(filterLanguage).filter(filterPreReleases).filter(filterDuplicates).map((_ref) => {
      let { language } = _ref,
          rest = _objectWithoutProperties(_ref, ['language']);

      return rest;
    });

    return {
      slug: seriesSlug,
      title,
      description,
      author,
      status,
      coverImageUrl,
      url,
      chapters
    };
  },

  async getChapter(_, chapterSlug) {
    const url = this.constructUrl(null, chapterSlug);
    const json = await throttledGet(`${this._getHost()}/api/chapter/${chapterSlug}`);

    // We get seriesSlug here since we don't have it from the URL, but
    // it's still needed to generate chapter IDs.
    const { manga_id: seriesSlug, page_array: pagePaths, server, hash } = json;
    const basename = json.server.startsWith('/data') ? `${this._getHost()}${server}${hash}` : `${server}${hash}`;

    const pages = pagePaths.map(path => {
      const url = `${basename}/${path}`;
      return { id: path, url };
    });

    return { slug: chapterSlug, url, seriesSlug, pages };
  }
};

exports.default = MangadexAdapter;
module.exports = exports['default'];