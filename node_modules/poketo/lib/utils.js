'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invariant = invariant;

var _url = require('url');

var _normalizeUrl = require('normalize-url');

var _normalizeUrl2 = _interopRequireDefault(_normalizeUrl);

var _pathMatch = require('path-match');

var _pathMatch2 = _interopRequireDefault(_pathMatch);

var _get = require('./get');

var _get2 = _interopRequireDefault(_get);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const timeout = 5 * 1000;
const match = (0, _pathMatch2.default)();

exports.default = {
  normalizeUrl(url) {
    return (0, _normalizeUrl2.default)(url);
  },

  parseUrl(url) {
    return new _url.URL(this.normalizeUrl(url));
  },

  compareDomain(a, b) {
    const hostnameA = this.parseUrl(a).hostname;
    const hostnameB = this.parseUrl(b).hostname;

    return hostnameA === hostnameB;
  },

  flatten(arr) {
    return [].concat(...arr);
  },

  uniq(arr) {
    return [...new Set(arr)];
  },

  range(low, high) {
    const result = [];
    for (let i = low; i <= high; i++) {
      result.push(i);
    }
    return result;
  },

  isNumber(val) {
    return Boolean(val) && !Number.isNaN(val);
  },

  sortChapters(arr) {
    return arr.slice().sort((a, b) => {
      const chapterA = parseFloat(a.chapterNumber);
      const volumeA = parseFloat(a.volumeNumber);
      const chapterB = parseFloat(b.chapterNumber);
      const volumeB = parseFloat(b.volumeNumber);

      if (this.isNumber(volumeA) && this.isNumber(volumeB)) {
        if (volumeA < volumeB) {
          return 1;
        }

        if (volumeA > volumeB) {
          return -1;
        }
      }

      if (!this.isNumber(chapterB)) {
        return -1;
      }

      if (!this.isNumber(chapterA)) {
        return 1;
      }

      return chapterB - chapterA;
    });
  },

  parseStatus(input, ongoingKey = 'ongoing', completedKey = 'complete') {
    const normalized = input.toLowerCase();

    if (normalized.indexOf(ongoingKey) !== -1) {
      return 'ONGOING';
    }

    if (normalized.indexOf(completedKey) !== -1) {
      return 'COMPLETED';
    }

    return 'UNKNOWN';
  },

  formatAuthors(authors) {
    const filteredAuthors = authors.map(author => author && author.trim()).filter(Boolean);

    const uniqueAuthors = filteredAuthors.filter((author, index, arr) => arr.indexOf(author) === index);

    return uniqueAuthors.length > 0 ? uniqueAuthors.join(', ') : null;
  },

  extractText(pattern, input, matchIndex = 1) {
    const matches = pattern.exec(input);

    if (!matches) {
      throw new Error(`Could not find matches for ${pattern.toString()}`);
    }

    if (!matches[matchIndex]) {
      throw new Error(`Could not find matches[${matchIndex}] for ${pattern.toString()}`);
    }

    return matches[matchIndex];
  },

  normalizeJson(input) {
    return input.replace(/'/g, '"') // Replace single quotes with double quotes
    .replace(/,]$/, ']'); // Remove trailing slashes
  },

  stripBBCode(input) {
    return input.replace(/\[\/?(?:b|i|u|url|quote|code|img|color|size)*?.*?\]/gim, '');
  },

  extractJSON(pattern, input) {
    const match = this.extractText(pattern, input);

    try {
      return JSON.parse(this.normalizeJson(match));
    } catch (err) {
      throw new Error(`Could not parse JSON`);
    }
  },

  /**
   * MangaFox uses these DM5 codes to encrypt strings needed to load their
   * images. DM5 codes are an encoded string and a legend, describing how to
   * decrypt the string. Sadly, DM5 uses `eval` and since we don't want to run
   * arbitrary `eval`'d code on people's computers, this function was written
   * to statically parse these strings.
   */
  decodeDM5String(encryptedString, keyString) {
    const keyArray = keyString.split('|');
    const keyLength = keyArray.length;

    const getChar = code => {
      const a = code < keyLength ? '' : getChar(parseInt(code / keyLength));
      const looped = code % keyLength;

      const b = looped > 35 ? String.fromCharCode(looped + 29) : looped.toString(36);

      return a + b;
    };

    let decodingKey = {};
    let i = keyLength;

    while (i--) {
      decodingKey[getChar(i)] = keyArray[i] || getChar(i);
    }

    return encryptedString.replace(/\b\w+\b/g, e => decodingKey[e]);
  },

  pathMatch(url, pattern) {
    const { pathname } = this.parseUrl(url);
    // NOTE: we normalize urls to always have a trailing slash here. This makes
    // matching with path-match easier, since we can then do patterns like
    // /:seriesSlug/:chapterSlug which works even if there's no chapterSlug
    // segment.
    const pathnameWithTrailingSlash = pathname + '/';
    const matches = match(pattern)(pathnameWithTrailingSlash);

    if (matches === false) {
      return null;
    }

    return matches;
  },

  generateId: (site, series, chapter) => [site, series, chapter].filter(Boolean).join(':'),

  async getPage(url, opts) {
    const res = await (0, _get2.default)(url, Object.assign({ timeout }, opts));
    const html = res.body;
    return html;
  },

  async getJSON(url, opts) {
    const res = await (0, _get2.default)(url, Object.assign({ json: true, timeout }, opts));
    const json = res.body;
    return json;
  }
};

/*
 * We're rolling our own version of 'assert' since Node's keeps throwing
 * 'AssertionErrors' rather than our custom error types. Grrrr.
 */

function invariant(condition, err) {
  if (condition) {
    return;
  }

  throw err;
}