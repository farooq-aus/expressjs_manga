'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _adapters = require('./adapters');

var _adapters2 = _interopRequireDefault(_adapters);

var _errors = require('./errors');

var _errors2 = _interopRequireDefault(_errors);

var _get = require('./get');

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isUrl(input) {
  return (/^https?/.test(input)
  );
}

function isPoketoId(input) {
  const components = input.split(':');
  const isValidId = components.length > 1 && components.length < 4;
  return !isUrl(input) && isValidId;
}

function isChapter(components) {
  return components.chapterSlug !== null && components.chapterSlug !== undefined;
}

function parseId(id) {
  (0, _utils.invariant)(isPoketoId(id), new _errors2.default.InvalidIdError(id));

  const components = id.split(':');

  const [siteId, seriesSlug, chapterSlug] = components;
  const isValidSiteId = _adapters2.default.map(adapter => adapter.id).includes(siteId);

  (0, _utils.invariant)(isValidSiteId, new _errors2.default.UnsupportedSiteError(siteId));

  return { siteId, seriesSlug, chapterSlug };
}

function getComponentsFromIdOrUrl(idOrUrl) {
  if (isUrl(idOrUrl)) {
    const site = getAdapterByUrl(idOrUrl);
    return Object.assign({ siteId: site.id }, site.parseUrl(idOrUrl));
  }

  if (isPoketoId(idOrUrl)) {
    return parseId(idOrUrl);
  }

  throw new _errors2.default.InvalidIdError(idOrUrl);
}

function getAdapterByUrl(url) {
  const adapter = _adapters2.default.find(adapter => adapter.supportsUrl(url));
  (0, _utils.invariant)(adapter, new _errors2.default.UnsupportedSiteError(url));
  return adapter;
}

function getAdapterBySiteId(siteId) {
  const adapter = _adapters2.default.find(adapter => adapter.id === siteId);
  (0, _utils.invariant)(adapter, new _errors2.default.UnsupportedSiteError(siteId));
  return adapter;
}

const poketo = {
  /*
   * Returns the URL for a given chapter or series based on the components
   * passed in. This URL is not guaranteed to be live or reachable.
   *
   * Meant for reconstructing URLs from pieces in routes.
   */
  constructUrl(id) {
    (0, _utils.invariant)(typeof id === 'string', new TypeError(`'constructUrl' must be passed a string, not ${typeof id}`));

    const components = parseId(id);

    const site = getAdapterBySiteId(components.siteId);
    return site.constructUrl(components.seriesSlug, components.chapterSlug);
  },

  getId(url) {
    (0, _utils.invariant)(typeof url === 'string', new TypeError(`'getType' must be passed a string, not ${typeof url}`));

    if (isPoketoId(url)) {
      return url;
    }

    const site = getAdapterByUrl(url);
    const components = site.parseUrl(url);

    (0, _utils.invariant)(components.seriesSlug, `Cannot generate an ID for '${url}' since the series information is missing. Use poketo.getSeries() or poketo.getChapter() instead.`);

    return _utils2.default.generateId(site.id, components.seriesSlug, components.chapterSlug);
  },

  getType(input) {
    (0, _utils.invariant)(typeof input === 'string', new TypeError(`'getType' must be passed a string, not ${typeof input}`));

    const components = getComponentsFromIdOrUrl(input);

    return isChapter(components) ? 'chapter' : 'series';
  },

  setDefaultHeaders(headers) {
    (0, _get.setDefaultHeaders)(headers);
  },

  /*
   * Returns a `Series` object with details about a manga series at the given
   * URL. If the URL is not supported, an error will be thrown.
   */
  async getSeries(input) {
    (0, _utils.invariant)(typeof input === 'string', new TypeError(`'getSeries' expects a string, not ${typeof input}`));

    const components = getComponentsFromIdOrUrl(input);
    const site = getAdapterBySiteId(components.siteId);

    const ErrorType = isUrl(input) ? _errors2.default.InvalidUrlError : _errors2.default.InvalidIdError;

    (0, _utils.invariant)(components.seriesSlug, new ErrorType(input));

    const seriesData = await site.getSeries(components.seriesSlug);

    const series = Object.assign({}, seriesData, {
      id: _utils2.default.generateId(site.id, seriesData.slug),
      site: {
        id: site.id,
        name: site.name
      },
      supportsReading: site.supportsReading(),
      updatedAt: seriesData.updatedAt ? seriesData.updatedAt : (seriesData.chapters || []).reduce((a, b) => Math.max(a, b.createdAt), 0)
    });

    if (seriesData.chapters) {
      series.chapters = _utils2.default.sortChapters(seriesData.chapters);
      series.chapters = series.chapters.map((chapterData, index) => Object.assign({}, chapterData, {
        id: _utils2.default.generateId(site.id, seriesData.slug, chapterData.slug),
        order: series.chapters.length - index - 1
      }));
    }

    return series;
  },

  /*
   * Returns a `Chapter` object with details about a single chapter of a manga
   * series from a given URL. If the URL is not supported, an error will be thrown.
   */
  async getChapter(input) {
    (0, _utils.invariant)(typeof input === 'string', new TypeError(`'getChapter' expects a string, not ${typeof input}`));

    const components = getComponentsFromIdOrUrl(input);
    const site = getAdapterBySiteId(components.siteId);

    const ErrorType = isUrl(input) ? _errors2.default.InvalidUrlError : _errors2.default.InvalidIdError;

    // NOTE: we don't check for series slug here since some sites (eg. Mangadex)
    // have chapter-only urls (eg. https://mangadex.org/chapter/123456). Only the
    // chapter url is really required.
    (0, _utils.invariant)(components.chapterSlug, new ErrorType(input));

    const chapterData = await site.getChapter(components.seriesSlug, components.chapterSlug);
    const seriesSlug = components.seriesSlug || chapterData.seriesSlug;

    (0, _utils.invariant)(seriesSlug, new ErrorType(input));

    const id = _utils2.default.generateId(site.id, seriesSlug, components.chapterSlug);
    const { url, pages } = chapterData;

    return { id, url, pages };
  }
};

Object.assign(poketo, _errors2.default);

exports.default = poketo;
module.exports = exports['default'];